#!/usr/bin/env python3
"""
symmap - WLA-DX Symbol Map Analyzer for SNES Development

Parses .sym files generated by wlalink and provides:
- Memory layout visualization
- WRAM mirroring overlap detection
- Symbol search
- JSON/HTML export

Usage:
    symmap game.sym                    # Show memory layout
    symmap --check-overlap game.sym    # Check for WRAM mirror overlaps
    symmap --find monster_x game.sym   # Find a symbol
    symmap --export-json game.sym      # Export to JSON
"""

import argparse
import json
import re
import sys
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional


# ANSI colors for terminal output
class Colors:
    RED = '\033[91m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    BOLD = '\033[1m'
    RESET = '\033[0m'

    @classmethod
    def disable(cls):
        cls.RED = cls.GREEN = cls.YELLOW = cls.BLUE = cls.CYAN = cls.BOLD = cls.RESET = ''


@dataclass
class Symbol:
    """Represents a symbol from the .sym file"""
    name: str
    bank: int
    address: int  # 16-bit address within bank
    full_address: int  # Full 24-bit address

    @property
    def is_in_wram_mirror(self) -> bool:
        """Check if this symbol is in the WRAM mirror range ($00:0000-$1FFF)"""
        return self.bank == 0x00 and self.address < 0x2000

    @property
    def is_in_wram(self) -> bool:
        """Check if this symbol is in Bank $7E WRAM"""
        return self.bank == 0x7E

    @property
    def mirror_address(self) -> Optional[int]:
        """If in WRAM or mirror, return the corresponding address in the other bank"""
        if self.is_in_wram_mirror:
            return 0x7E0000 + self.address
        elif self.is_in_wram and self.address < 0x2000:
            return self.address
        return None


@dataclass
class MemoryRegion:
    """A contiguous region of memory containing symbols"""
    bank: int
    start_address: int
    end_address: int
    symbols: list = field(default_factory=list)

    @property
    def size(self) -> int:
        return self.end_address - self.start_address + 1


@dataclass
class Overlap:
    """Represents a memory overlap between two symbols"""
    bank0_symbol: Symbol
    bank7e_symbol: Symbol
    overlap_start: int
    overlap_end: int

    @property
    def overlap_size(self) -> int:
        return self.overlap_end - self.overlap_start + 1


class SymbolTable:
    """Parser and analyzer for WLA-DX .sym files"""

    # Bank descriptions for SNES LoROM
    BANK_DESCRIPTIONS = {
        0x00: "LoROM Bank 0 (WRAM Mirror $0000-$1FFF)",
        0x7E: "Work RAM (64KB)",
        0x7F: "Extended RAM (64KB)",
    }

    def __init__(self):
        self.symbols: dict[str, Symbol] = {}  # name -> Symbol
        self.banks: dict[int, list[Symbol]] = {}  # bank -> list of symbols

    def parse(self, sym_path: Path) -> None:
        """Parse a WLA-DX .sym file"""
        with open(sym_path, 'r') as f:
            for line in f:
                line = line.strip()

                # Skip comments and empty lines
                if not line or line.startswith(';'):
                    continue

                # Try colon format first: "BB:AAAA symbol_name"
                # Example: "00:81b9 EmptyHandler"
                match = re.match(r'^([0-9a-fA-F]{2}):([0-9a-fA-F]{4})\s+(\S+)$', line)
                if match:
                    bank_str, addr_str, name = match.groups()
                    bank = int(bank_str, 16)
                    address = int(addr_str, 16)
                    full_addr = (bank << 16) | address
                else:
                    # Try legacy 8-char format: "00BBAAAA symbol_name"
                    match = re.match(r'^([0-9a-fA-F]{8})\s+(\S+)$', line)
                    if not match:
                        continue
                    full_addr_str, name = match.groups()
                    full_addr = int(full_addr_str, 16)
                    bank = (full_addr >> 16) & 0xFF
                    address = full_addr & 0xFFFF

                symbol = Symbol(
                    name=name,
                    bank=bank,
                    address=address,
                    full_address=full_addr
                )

                self.symbols[name] = symbol

                if bank not in self.banks:
                    self.banks[bank] = []
                self.banks[bank].append(symbol)

        # Sort symbols in each bank by address
        for bank in self.banks:
            self.banks[bank].sort(key=lambda s: s.address)

    def find_symbol(self, name: str, fuzzy: bool = False) -> list[Symbol]:
        """Find symbol(s) by name"""
        if not fuzzy:
            if name in self.symbols:
                return [self.symbols[name]]
            return []

        # Fuzzy match: find all symbols containing the search string
        results = []
        name_lower = name.lower()
        for sym_name, symbol in self.symbols.items():
            if name_lower in sym_name.lower():
                results.append(symbol)
        return sorted(results, key=lambda s: s.name)

    def check_wram_overlap(self) -> list[Overlap]:
        """
        Check for WRAM mirroring overlaps.

        CRITICAL: Bank $00:$0000-$1FFF mirrors Bank $7E:$0000-$1FFF.
        If both banks have symbols in the same address range, they will
        collide and overwrite each other!
        """
        overlaps = []

        # Get symbols in the mirror ranges
        bank0_mirror = [s for s in self.banks.get(0x00, [])
                        if s.address < 0x2000]
        bank7e_mirror = [s for s in self.banks.get(0x7E, [])
                         if s.address < 0x2000]

        if not bank0_mirror or not bank7e_mirror:
            return []

        # Check each pair for overlap
        for s0 in bank0_mirror:
            for s7e in bank7e_mirror:
                # Check if ranges overlap
                # For now, assume each symbol is at least 1 byte
                # We can't know exact sizes without section info
                if s0.address == s7e.address:
                    overlaps.append(Overlap(
                        bank0_symbol=s0,
                        bank7e_symbol=s7e,
                        overlap_start=s0.address,
                        overlap_end=s0.address
                    ))

        # Also check for range overlaps by finding the extents
        if bank0_mirror and bank7e_mirror:
            bank0_min = min(s.address for s in bank0_mirror)
            bank0_max = max(s.address for s in bank0_mirror)
            bank7e_min = min(s.address for s in bank7e_mirror)
            bank7e_max = max(s.address for s in bank7e_mirror)

            # Check if ranges overlap at all
            if not (bank0_max < bank7e_min or bank7e_max < bank0_min):
                overlap_start = max(bank0_min, bank7e_min)
                overlap_end = min(bank0_max, bank7e_max)

                # Find which symbols are in the overlap range
                overlap_bank0 = [s for s in bank0_mirror
                                 if overlap_start <= s.address <= overlap_end]
                overlap_bank7e = [s for s in bank7e_mirror
                                  if overlap_start <= s.address <= overlap_end]

                if overlap_bank0 and overlap_bank7e:
                    # Create a single comprehensive overlap entry
                    overlaps.append(Overlap(
                        bank0_symbol=overlap_bank0[0],
                        bank7e_symbol=overlap_bank7e[0],
                        overlap_start=overlap_start,
                        overlap_end=overlap_end
                    ))

        return overlaps

    def get_memory_map(self) -> dict:
        """Generate a memory map summary"""
        result = {}

        for bank, symbols in sorted(self.banks.items()):
            bank_info = {
                'description': self.BANK_DESCRIPTIONS.get(bank, f"Bank ${bank:02X}"),
                'symbol_count': len(symbols),
                'symbols': []
            }

            for sym in symbols:
                bank_info['symbols'].append({
                    'name': sym.name,
                    'address': f"${sym.address:04X}",
                    'full_address': f"${sym.full_address:06X}",
                    'in_wram_mirror': sym.is_in_wram_mirror,
                })

            result[f"${bank:02X}"] = bank_info

        return result


def print_memory_layout(table: SymbolTable, verbose: bool = False):
    """Print a formatted memory layout"""
    print(f"{Colors.BOLD}=== Memory Layout ==={Colors.RESET}\n")

    for bank in sorted(table.banks.keys()):
        symbols = table.banks[bank]
        desc = table.BANK_DESCRIPTIONS.get(bank, "")

        print(f"{Colors.CYAN}BANK ${bank:02X}{Colors.RESET}", end="")
        if desc:
            print(f" ({desc})")
        else:
            print()

        if verbose:
            for sym in symbols:
                warning = ""
                if sym.is_in_wram_mirror:
                    warning = f" {Colors.YELLOW}[WRAM Mirror]{Colors.RESET}"
                print(f"  ${sym.address:04X}  {sym.name}{warning}")
        else:
            # Show summary
            if symbols:
                print(f"  ${symbols[0].address:04X}-${symbols[-1].address:04X}  "
                      f"({len(symbols)} symbols)")

        print()


def print_overlap_check(table: SymbolTable) -> int:
    """Check and print WRAM mirror overlaps. Returns exit code."""
    overlaps = table.check_wram_overlap()

    # Get symbols in each mirror range
    bank0_mirror = [s for s in table.banks.get(0x00, []) if s.address < 0x2000]
    bank7e_mirror = [s for s in table.banks.get(0x7E, []) if s.address < 0x2000]

    if not bank0_mirror and not bank7e_mirror:
        print(f"{Colors.GREEN}OK: No symbols in WRAM mirror range{Colors.RESET}")
        return 0

    if not bank0_mirror or not bank7e_mirror:
        print(f"{Colors.GREEN}OK: Only one bank uses WRAM mirror range{Colors.RESET}")
        print(f"  Bank $00: {len(bank0_mirror)} symbols in $0000-$1FFF")
        print(f"  Bank $7E: {len(bank7e_mirror)} symbols in $0000-$1FFF")
        return 0

    # Both banks have symbols - check for actual overlap
    bank0_max = max(s.address for s in bank0_mirror)
    bank7e_min = min(s.address for s in bank7e_mirror)

    if bank0_max < bank7e_min:
        print(f"{Colors.GREEN}OK: No overlap detected{Colors.RESET}")
        print(f"  Bank $00: $0000-${bank0_max:04X} ({len(bank0_mirror)} symbols)")
        print(f"  Bank $7E: ${bank7e_min:04X}-... ({len(bank7e_mirror)} symbols)")
        return 0

    # OVERLAP DETECTED!
    print(f"{Colors.RED}{Colors.BOLD}ERROR: WRAM Mirror Overlap Detected!{Colors.RESET}\n")

    print(f"{Colors.YELLOW}Bank $00 (LoROM Mirror) symbols in $0000-$1FFF:{Colors.RESET}")
    for s in bank0_mirror[:10]:  # Show first 10
        print(f"  ${s.address:04X}  {s.name}")
    if len(bank0_mirror) > 10:
        print(f"  ... and {len(bank0_mirror) - 10} more")

    print()
    print(f"{Colors.YELLOW}Bank $7E (WRAM) symbols in $0000-$1FFF:{Colors.RESET}")
    for s in bank7e_mirror[:10]:
        print(f"  ${s.address:04X}  {s.name}")
    if len(bank7e_mirror) > 10:
        print(f"  ... and {len(bank7e_mirror) - 10} more")

    print()
    print(f"{Colors.RED}COLLISION:{Colors.RESET} Both banks have symbols at overlapping addresses!")
    print(f"  Bank $00 range: $0000-${bank0_max:04X}")
    print(f"  Bank $7E range: ${bank7e_min:04X}-${max(s.address for s in bank7e_mirror):04X}")
    print()
    print(f"{Colors.CYAN}FIX:{Colors.RESET} Add 'ORGA $0300 FORCE' to Bank $7E RAMSECTION definitions")
    print(f"     to place them above the Bank $00 mirror range ($0000-$1FFF)")

    return 1


def print_symbol_search(table: SymbolTable, name: str):
    """Search for and print symbol information"""
    results = table.find_symbol(name, fuzzy=True)

    if not results:
        print(f"{Colors.YELLOW}No symbols found matching '{name}'{Colors.RESET}")
        return

    print(f"{Colors.BOLD}Found {len(results)} symbol(s):{Colors.RESET}\n")

    for sym in results:
        print(f"{Colors.CYAN}{sym.name}{Colors.RESET}")
        print(f"  Address: ${sym.bank:02X}:{sym.address:04X} (${sym.full_address:06X})")

        # Warnings
        if sym.is_in_wram_mirror:
            print(f"  {Colors.YELLOW}WARNING: In WRAM mirror range ($0000-$1FFF){Colors.RESET}")
            print(f"           This address is shared with $7E:{sym.address:04X}")

        print()


def export_json(table: SymbolTable) -> str:
    """Export memory map to JSON"""
    data = {
        'symbols': {},
        'banks': {},
        'wram_overlap_check': None
    }

    # Export all symbols
    for name, sym in table.symbols.items():
        data['symbols'][name] = {
            'bank': sym.bank,
            'address': sym.address,
            'full_address': sym.full_address,
            'in_wram_mirror': sym.is_in_wram_mirror
        }

    # Export bank summaries
    for bank, symbols in table.banks.items():
        data['banks'][f"0x{bank:02X}"] = {
            'symbol_count': len(symbols),
            'address_range': {
                'min': min(s.address for s in symbols) if symbols else 0,
                'max': max(s.address for s in symbols) if symbols else 0
            }
        }

    # Export overlap check result
    overlaps = table.check_wram_overlap()
    data['wram_overlap_check'] = {
        'has_overlap': len(overlaps) > 0,
        'overlaps': [
            {
                'bank0_symbol': o.bank0_symbol.name,
                'bank7e_symbol': o.bank7e_symbol.name,
                'address_range': f"${o.overlap_start:04X}-${o.overlap_end:04X}"
            }
            for o in overlaps
        ]
    }

    return json.dumps(data, indent=2)


def main():
    parser = argparse.ArgumentParser(
        description='WLA-DX Symbol Map Analyzer for SNES Development',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  symmap game.sym                    Show memory layout summary
  symmap -v game.sym                 Show detailed memory layout
  symmap --check-overlap game.sym   Check for WRAM mirror overlaps
  symmap --find monster_x game.sym   Find symbol by name
  symmap --export-json game.sym      Export to JSON format
"""
    )

    parser.add_argument('sym_file', type=Path, help='Path to .sym file')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Show all symbols in memory layout')
    parser.add_argument('--check-overlap', action='store_true',
                        help='Check for WRAM mirror overlaps (main use case)')
    parser.add_argument('--find', metavar='NAME',
                        help='Find symbol by name (fuzzy match)')
    parser.add_argument('--export-json', action='store_true',
                        help='Export memory map to JSON')
    parser.add_argument('--no-color', action='store_true',
                        help='Disable colored output')

    args = parser.parse_args()

    # Disable colors if requested or not a TTY
    if args.no_color or not sys.stdout.isatty():
        Colors.disable()

    # Check file exists
    if not args.sym_file.exists():
        print(f"{Colors.RED}ERROR: File not found: {args.sym_file}{Colors.RESET}",
              file=sys.stderr)
        return 1

    # Parse symbol file
    table = SymbolTable()
    try:
        table.parse(args.sym_file)
    except Exception as e:
        print(f"{Colors.RED}ERROR: Failed to parse {args.sym_file}: {e}{Colors.RESET}",
              file=sys.stderr)
        return 1

    print(f"Loaded {len(table.symbols)} symbols from {args.sym_file.name}\n")

    # Handle requested operation
    if args.export_json:
        print(export_json(table))
        return 0

    if args.check_overlap:
        return print_overlap_check(table)

    if args.find:
        print_symbol_search(table, args.find)
        return 0

    # Default: show memory layout
    print_memory_layout(table, verbose=args.verbose)
    return 0


if __name__ == '__main__':
    sys.exit(main())
