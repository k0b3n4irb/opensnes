/**
 * @file output.c
 * @brief Output file generation implementation
 *
 * License: MIT
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "output.h"

/* Get printable character representation for comments */
static const char *char_repr(int ascii_code)
{
    static char buf[8];

    if (ascii_code == 32) {
        return "space";
    } else if (ascii_code == 127) {
        return "DEL";
    } else if (ascii_code >= 33 && ascii_code < 127) {
        buf[0] = (char)ascii_code;
        buf[1] = '\0';
        return buf;
    } else {
        snprintf(buf, sizeof(buf), "0x%02X", ascii_code);
        return buf;
    }
}

/* Convert name to valid C identifier (uppercase) */
static void name_to_identifier(const char *name, char *ident, size_t size)
{
    size_t i, j = 0;

    for (i = 0; name[i] && j < size - 1; i++) {
        char c = name[i];
        if (isalnum((unsigned char)c)) {
            ident[j++] = (char)toupper((unsigned char)c);
        } else if (c == '_' || c == '-' || c == '.') {
            ident[j++] = '_';
        }
    }
    ident[j] = '\0';
}

int output_c_header(const font_data_t *font, const char *output_path)
{
    FILE *f;
    char ident[64];
    int i, j;
    int total_bytes;

    f = fopen(output_path, "w");
    if (!f) {
        fprintf(stderr, "Error: Cannot open %s for writing\n", output_path);
        return -1;
    }

    name_to_identifier(font->name, ident, sizeof(ident));
    total_bytes = font->tile_count * font->bytes_per_tile;

    /* Header */
    fprintf(f, "/**\n");
    fprintf(f, " * @file %s\n", output_path);
    fprintf(f, " * @brief SNES Font - %dbpp format (%d characters)\n",
            font->bpp, font->tile_count);
    fprintf(f, " *\n");
    fprintf(f, " * Auto-generated by font2snes\n");
    fprintf(f, " * %d bytes per tile, %d bytes total\n",
            font->bytes_per_tile, total_bytes);
    fprintf(f, " *\n");
    fprintf(f, " * License: CC0 (Public Domain)\n");
    fprintf(f, " */\n\n");

    fprintf(f, "#ifndef %s_H\n", ident);
    fprintf(f, "#define %s_H\n\n", ident);

    /* Constants */
    fprintf(f, "#define %s_CHAR_COUNT     %d\n", ident, font->tile_count);
    fprintf(f, "#define %s_FIRST_CHAR     32  /* ASCII space */\n", ident);
    fprintf(f, "#define %s_BYTES_PER_CHAR %d\n", ident, font->bytes_per_tile);
    fprintf(f, "#define %s_BPP            %d\n\n", ident, font->bpp);

    /* Tile data */
    fprintf(f, "/**\n");
    fprintf(f, " * @brief Font tile data in SNES %dbpp format\n", font->bpp);
    fprintf(f, " *\n");
    fprintf(f, " * Index = (ASCII code - %s_FIRST_CHAR) * %s_BYTES_PER_CHAR\n",
            ident, ident);
    fprintf(f, " */\n");
    fprintf(f, "static const unsigned char %s_tiles[%d] = {\n",
            font->name, total_bytes);

    for (i = 0; i < font->tile_count; i++) {
        int ascii_code = i + 32;
        int offset = i * font->bytes_per_tile;

        fprintf(f, "    /* %3d: '%s' */\n", ascii_code, char_repr(ascii_code));
        fprintf(f, "    ");

        for (j = 0; j < font->bytes_per_tile; j++) {
            fprintf(f, "0x%02X", font->tiles[offset + j]);
            if (i < font->tile_count - 1 || j < font->bytes_per_tile - 1) {
                fprintf(f, ",");
            }
            if (j == 7 && font->bytes_per_tile > 8) {
                fprintf(f, "\n    ");
            } else if (j < font->bytes_per_tile - 1) {
                fprintf(f, " ");
            }
        }
        fprintf(f, "\n");
    }

    fprintf(f, "};\n\n");

    /* Palette data */
    fprintf(f, "/**\n");
    fprintf(f, " * @brief Font palette in SNES BGR555 format\n");
    fprintf(f, " */\n");
    fprintf(f, "static const unsigned short %s_palette[%d] = {\n",
            font->name, font->palette_count);

    for (i = 0; i < font->palette_count; i++) {
        fprintf(f, "    0x%04X", font->palette[i]);
        if (i < font->palette_count - 1) {
            fprintf(f, ",");
        }
        fprintf(f, "  /* Color %d */\n", i);
    }

    fprintf(f, "};\n\n");

    fprintf(f, "#endif /* %s_H */\n", ident);

    fclose(f);
    return 0;
}

int output_binary_tiles(const font_data_t *font, const char *output_path)
{
    FILE *f;
    size_t total_bytes;
    size_t written;

    f = fopen(output_path, "wb");
    if (!f) {
        fprintf(stderr, "Error: Cannot open %s for writing\n", output_path);
        return -1;
    }

    total_bytes = (size_t)font->tile_count * font->bytes_per_tile;
    written = fwrite(font->tiles, 1, total_bytes, f);

    fclose(f);

    if (written != total_bytes) {
        fprintf(stderr, "Error: Failed to write all bytes to %s\n", output_path);
        return -1;
    }

    return 0;
}

int output_binary_palette(const font_data_t *font, const char *output_path)
{
    FILE *f;
    int i;

    f = fopen(output_path, "wb");
    if (!f) {
        fprintf(stderr, "Error: Cannot open %s for writing\n", output_path);
        return -1;
    }

    /* Write as little-endian 16-bit values */
    for (i = 0; i < font->palette_count; i++) {
        uint8_t lo = font->palette[i] & 0xFF;
        uint8_t hi = (font->palette[i] >> 8) & 0xFF;
        fputc(lo, f);
        fputc(hi, f);
    }

    fclose(f);
    return 0;
}
