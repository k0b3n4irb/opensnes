#!/usr/bin/env python3
"""
font2snes - Convert 1bpp font to SNES tile format

Converts 8x8 1bpp font bitmaps to SNES 2bpp or 4bpp tile format.

SNES Tile Formats:
  2bpp: 16 bytes per tile (rows 0-7 bitplane 0, then rows 0-7 bitplane 1)
  4bpp: 32 bytes per tile (2bpp low planes, then 2bpp high planes)

For 1bpp input, only bitplane 0 is used (colors 0 and 1 only).

Usage:
  python3 font2snes.py [options] input.h output.bin
  python3 font2snes.py --help

License: CC0 (Public Domain)
"""

import argparse
import re
import sys
from pathlib import Path


def parse_font_header(header_path: Path) -> list[list[int]]:
    """Parse a C header file containing font bitmap data.

    Expects format like:
        static const unsigned char font[96][8] = {
            { 0x00, 0x00, ... },  // character
            ...
        };

    Returns list of 8-byte character bitmaps.
    """
    content = header_path.read_text()

    # Find all hex byte sequences in braces
    pattern = r'\{\s*(0x[0-9A-Fa-f]{2}(?:\s*,\s*0x[0-9A-Fa-f]{2})*)\s*\}'
    matches = re.findall(pattern, content)

    characters = []
    for match in matches:
        # Extract hex values
        hex_values = re.findall(r'0x([0-9A-Fa-f]{2})', match)
        if len(hex_values) == 8:  # Valid 8x8 character
            characters.append([int(h, 16) for h in hex_values])

    return characters


def convert_1bpp_to_2bpp(char_data: list[int]) -> bytes:
    """Convert 8-byte 1bpp character to 16-byte SNES 2bpp tile.

    SNES 2bpp format (interleaved):
        Byte 0: Row 0, bitplane 0
        Byte 1: Row 0, bitplane 1
        Byte 2: Row 1, bitplane 0
        Byte 3: Row 1, bitplane 1
        ... and so on

    For 1bpp input, bitplane 1 is always 0 (using colors 0 and 1 only).
    """
    result = bytearray(16)
    for row in range(8):
        result[row * 2] = char_data[row]      # Bitplane 0
        result[row * 2 + 1] = 0               # Bitplane 1 (0 for 1bpp source)
    return bytes(result)


def convert_1bpp_to_4bpp(char_data: list[int]) -> bytes:
    """Convert 8-byte 1bpp character to 32-byte SNES 4bpp tile.

    SNES 4bpp format:
        Bytes 0-15: Low bitplanes (same as 2bpp)
        Bytes 16-31: High bitplanes (interleaved like 2bpp)

    For 1bpp input, only bitplane 0 is used (color 0 or 1).
    """
    result = bytearray(32)
    for row in range(8):
        result[row * 2] = char_data[row]      # Bitplane 0
        result[row * 2 + 1] = 0               # Bitplane 1
        result[16 + row * 2] = 0              # Bitplane 2
        result[16 + row * 2 + 1] = 0          # Bitplane 3
    return bytes(result)


def generate_c_header(characters: list[bytes], output_path: Path, bpp: int):
    """Generate a C header file with the converted font data."""
    bytes_per_tile = 16 if bpp == 2 else 32

    with open(output_path, 'w') as f:
        f.write(f"""/**
 * @file {output_path.name}
 * @brief OpenSNES Font - SNES {bpp}bpp format
 *
 * Auto-generated by font2snes.py
 * {len(characters)} characters, {bytes_per_tile} bytes per tile
 *
 * License: CC0 (Public Domain)
 */

#ifndef OPENSNES_FONT_{bpp}BPP_H
#define OPENSNES_FONT_{bpp}BPP_H

#define FONT_CHAR_COUNT {len(characters)}
#define FONT_BYTES_PER_CHAR {bytes_per_tile}
#define FONT_FIRST_CHAR 32  /* ASCII space */

/**
 * @brief Font tile data in SNES {bpp}bpp format
 *
 * Index = ASCII code - FONT_FIRST_CHAR
 */
static const unsigned char opensnes_font_{bpp}bpp[{len(characters) * bytes_per_tile}] = {{
""")

        for i, char_data in enumerate(characters):
            ascii_code = i + 32
            if ascii_code < 127:
                char_repr = chr(ascii_code) if ascii_code >= 33 else 'space'
            else:
                char_repr = 'DEL'

            f.write(f"    /* {ascii_code}: '{char_repr}' */\n    ")
            hex_bytes = ', '.join(f'0x{b:02X}' for b in char_data)
            f.write(hex_bytes)
            if i < len(characters) - 1:
                f.write(',')
            f.write('\n')

        f.write("""};

#endif
""")


def main():
    parser = argparse.ArgumentParser(
        description='Convert 1bpp font to SNES tile format',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s opensnes_font.h font.bin
  %(prog)s -b 4 opensnes_font.h font_4bpp.bin
  %(prog)s -c opensnes_font.h font_2bpp.h
"""
    )
    parser.add_argument('input', type=Path, help='Input font header file (.h)')
    parser.add_argument('output', type=Path, help='Output file (.bin or .h)')
    parser.add_argument('-b', '--bpp', type=int, choices=[2, 4], default=2,
                        help='Bits per pixel (default: 2)')
    parser.add_argument('-c', '--c-header', action='store_true',
                        help='Output as C header instead of binary')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Verbose output')

    args = parser.parse_args()

    # Parse input font
    if args.verbose:
        print(f"Reading font from {args.input}...")

    try:
        characters = parse_font_header(args.input)
    except Exception as e:
        print(f"Error reading input: {e}", file=sys.stderr)
        return 1

    if not characters:
        print("Error: No valid character data found in input", file=sys.stderr)
        return 1

    if args.verbose:
        print(f"Found {len(characters)} characters")

    # Convert to SNES format
    converter = convert_1bpp_to_2bpp if args.bpp == 2 else convert_1bpp_to_4bpp
    converted = [converter(char) for char in characters]

    # Write output
    if args.c_header:
        if args.verbose:
            print(f"Writing C header to {args.output}...")
        generate_c_header(converted, args.output, args.bpp)
    else:
        if args.verbose:
            print(f"Writing binary to {args.output}...")
        with open(args.output, 'wb') as f:
            for char_data in converted:
                f.write(char_data)

    bytes_per_tile = 16 if args.bpp == 2 else 32
    total_bytes = len(characters) * bytes_per_tile

    print(f"Converted {len(characters)} characters to {args.bpp}bpp format")
    print(f"Output: {args.output} ({total_bytes} bytes)")

    return 0


if __name__ == '__main__':
    sys.exit(main())
