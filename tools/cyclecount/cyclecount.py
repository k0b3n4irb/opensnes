#!/usr/bin/env python3
"""65816 Assembly Cycle Counter for OpenSNES compiler output.

Analyzes .asm files generated by cc65816 (cproc + QBE w65816 backend)
and estimates CPU cycle costs per function based on the 65816 instruction
timing reference.

Usage:
    python3 cyclecount.py file.asm                        # Analyze one file
    python3 cyclecount.py --compare before.asm after.asm  # Compare two files
    python3 cyclecount.py --verbose file.asm              # Per-instruction detail
    python3 cyclecount.py --json file.asm                 # Machine-readable output

Assumptions (matching cc65816 defaults):
    - Native 65816 mode (not emulation)
    - 16-bit accumulator (m=0) unless sep/rep changes it
    - 16-bit index registers (x=0) unless sep/rep changes it
    - Direct page register aligned to $0000 (no +1 DP penalty)
    - Branches counted at base cost (not-taken); use --branches-taken for +1

Reference: https://wiki.superfamicom.org/65816-reference
"""

import re
import sys
import json
import argparse
from collections import OrderedDict

# ---------------------------------------------------------------------------
# 65816 Cycle Count Tables
# ---------------------------------------------------------------------------
# Base cycles per (mnemonic, addressing_mode).
# Flag-dependent adjustments applied separately.

# Addressing mode keys:
#   imp  = implied           acc  = accumulator        imm  = immediate
#   dp   = direct page       dpx  = DP indexed X       dpy  = DP indexed Y
#   abs  = absolute          abx  = abs indexed X      aby  = abs indexed Y
#   abl  = absolute long     alx  = abs long indexed X
#   dpi  = DP indirect       dix  = DP indexed ind X   diy  = DP ind indexed Y
#   dli  = DP indirect long  dly  = DP ind long idx Y
#   sr   = stack relative    sry  = SR ind indexed Y
#   rel  = relative branch   rll  = relative long
#   ind  = abs indirect      aix  = abs indexed ind    ail  = abs indirect long

# ALU load pattern (ADC AND CMP EOR LDA ORA SBC)
_ALU = {
    'imm': 2, 'dp': 3, 'dpx': 4, 'dpy': 4, 'abs': 4, 'abx': 4, 'aby': 4,
    'abl': 5, 'alx': 5, 'dpi': 5, 'dix': 6, 'diy': 5, 'dli': 6, 'dly': 6,
    'sr': 4, 'sry': 7,
}

# Store pattern (STA) — indexed modes cost 1 more than loads
_STA = {
    'dp': 3, 'dpx': 4, 'abs': 4, 'abx': 5, 'aby': 5,
    'abl': 5, 'alx': 5, 'dpi': 5, 'dix': 6, 'diy': 6, 'dli': 6, 'dly': 6,
    'sr': 4, 'sry': 7,
}

# Shift/RMW pattern (ASL LSR ROL ROR INC DEC)
_SHIFT = {'acc': 2, 'dp': 5, 'dpx': 6, 'abs': 6, 'abx': 7}

CYCLES = {
    # ALU operations
    'adc': dict(_ALU), 'and': dict(_ALU), 'cmp': dict(_ALU),
    'eor': dict(_ALU), 'lda': dict(_ALU), 'ora': dict(_ALU),
    'sbc': dict(_ALU),
    # Stores
    'sta': dict(_STA),
    'stz': {'dp': 3, 'dpx': 4, 'abs': 4, 'abx': 5},
    # Compare index
    'cpx': {'imm': 2, 'dp': 3, 'abs': 4},
    'cpy': {'imm': 2, 'dp': 3, 'abs': 4},
    # Load index
    'ldx': {'imm': 2, 'dp': 3, 'dpy': 4, 'abs': 4, 'aby': 4},
    'ldy': {'imm': 2, 'dp': 3, 'dpx': 4, 'abs': 4, 'abx': 4},
    # Store index
    'stx': {'dp': 3, 'dpy': 4, 'abs': 4},
    'sty': {'dp': 3, 'dpx': 4, 'abs': 4},
    # Bit test
    'bit': {'imm': 2, 'dp': 3, 'dpx': 4, 'abs': 4, 'abx': 4},
    # Shifts and RMW
    'asl': dict(_SHIFT), 'lsr': dict(_SHIFT), 'rol': dict(_SHIFT),
    'ror': dict(_SHIFT), 'inc': dict(_SHIFT), 'dec': dict(_SHIFT),
    # Test and set/reset
    'trb': {'dp': 5, 'abs': 6},
    'tsb': {'dp': 5, 'abs': 6},
    # Branches
    'bcc': {'rel': 2}, 'bcs': {'rel': 2}, 'beq': {'rel': 2},
    'bne': {'rel': 2}, 'bpl': {'rel': 2}, 'bmi': {'rel': 2},
    'bvc': {'rel': 2}, 'bvs': {'rel': 2}, 'bra': {'rel': 3},
    'brl': {'rll': 4},
    # WLA-DX branch aliases
    'blt': {'rel': 2},  # = bcc
    'bge': {'rel': 2},  # = bcs
    # Jumps
    'jmp': {'abs': 3, 'abl': 4, 'ind': 5, 'aix': 6, 'ail': 6},
    'jml': {'abl': 4, 'ail': 6, 'ind': 6},
    'jsr': {'abs': 6, 'abl': 8, 'aix': 8},
    'jsl': {'abl': 8},
    # Returns
    'rtl': {'imp': 6}, 'rts': {'imp': 6}, 'rti': {'imp': 6},
    # Stack push
    'pha': {'imp': 3}, 'phx': {'imp': 3}, 'phy': {'imp': 3},
    'php': {'imp': 3}, 'phb': {'imp': 3}, 'phd': {'imp': 4},
    'phk': {'imp': 3},
    # Stack pull
    'pla': {'imp': 4}, 'plx': {'imp': 4}, 'ply': {'imp': 4},
    'plp': {'imp': 4}, 'plb': {'imp': 4}, 'pld': {'imp': 5},
    # Stack misc
    'pea': {'abs': 5}, 'pei': {'dpi': 6}, 'per': {'rll': 6},
    # Flag operations
    'clc': {'imp': 2}, 'sec': {'imp': 2}, 'cli': {'imp': 2},
    'sei': {'imp': 2}, 'cld': {'imp': 2}, 'sed': {'imp': 2},
    'clv': {'imp': 2},
    # Mode switches
    'rep': {'imm': 3}, 'sep': {'imm': 3},
    # Transfers
    'tax': {'imp': 2}, 'tay': {'imp': 2}, 'txa': {'imp': 2},
    'tya': {'imp': 2}, 'txy': {'imp': 2}, 'tyx': {'imp': 2},
    'tcd': {'imp': 2}, 'tdc': {'imp': 2}, 'tcs': {'imp': 2},
    'tsc': {'imp': 2}, 'tsx': {'imp': 2}, 'txs': {'imp': 2},
    # WLA-DX aliases for transfers
    'tas': {'imp': 2},  # = tcs
    'tsa': {'imp': 2},  # = tsc
    # Increment/decrement index
    'inx': {'imp': 2}, 'iny': {'imp': 2},
    'dex': {'imp': 2}, 'dey': {'imp': 2},
    # Accumulator inc/dec aliases
    'ina': {'imp': 2},  # = inc a
    'dea': {'imp': 2},  # = dec a
    # Misc
    'nop': {'imp': 2}, 'xba': {'imp': 3}, 'xce': {'imp': 2},
    'stp': {'imp': 3}, 'wai': {'imp': 3},
    'brk': {'imp': 7}, 'cop': {'imm': 7},
    # Block moves (variable cost, count as 7 per byte moved)
    'mvn': {'blk': 7}, 'mvp': {'blk': 7},
    'wdm': {'imp': 2},
}

# Instructions where m=0 (16-bit A) adds +1 cycle
M_PLUS1 = {
    'adc', 'and', 'bit', 'cmp', 'eor', 'lda', 'ora', 'sbc',  # ALU loads
    'sta', 'stz',  # stores
    'pha', 'pla',  # push/pull A
}

# Instructions where m=0 adds +2 cycle (memory shift/RMW, NOT accumulator)
M_PLUS2 = {'asl', 'lsr', 'rol', 'ror', 'inc', 'dec', 'trb', 'tsb'}

# Instructions where x=0 (16-bit index) adds +1 cycle
X_PLUS1 = {
    'cpx', 'cpy', 'ldx', 'ldy', 'stx', 'sty',  # index ops
    'phx', 'phy', 'plx', 'ply',  # push/pull index
}

# Shift mnemonics that default to accumulator when no operand
SHIFT_MNEMONICS = {'asl', 'lsr', 'rol', 'ror', 'inc', 'dec'}


# ---------------------------------------------------------------------------
# Operand parser — determines addressing mode from WLA-DX syntax
# ---------------------------------------------------------------------------

def parse_addressing_mode(mnemonic, operand, size_hint):
    """Determine addressing mode from operand string.

    Args:
        mnemonic: base mnemonic (lowercase, no suffix)
        operand: operand string (stripped)
        size_hint: 'b', 'w', 'l', or None (from .b/.w/.l suffix)

    Returns:
        Addressing mode string (e.g. 'imm', 'sr', 'abs', etc.)
    """
    if not operand:
        if mnemonic in SHIFT_MNEMONICS:
            return 'acc'
        return 'imp'

    op = operand.lower().strip()

    # Accumulator
    if op == 'a':
        return 'acc'

    # (N,s),y — stack relative indirect indexed Y
    if re.match(r'\(\d+,s\),y$', op):
        return 'sry'

    # N,s — stack relative
    if re.match(r'.+,s$', op):
        return 'sr'

    # #value — immediate
    if op.startswith('#'):
        return 'imm'

    # [addr],y — DP indirect long indexed Y
    if re.match(r'\[.+\],y$', op):
        return 'dly'

    # [addr] — indirect long
    if re.match(r'\[.+\]$', op):
        if mnemonic in ('jmp', 'jml'):
            return 'ail'
        return 'dli'

    # (addr,x) — indexed indirect
    if re.match(r'\(.+,x\)$', op):
        if mnemonic in ('jmp', 'jsr'):
            return 'aix'
        return 'dix'

    # (addr),y — indirect indexed Y
    if re.match(r'\(.+\),y$', op):
        return 'diy'

    # (addr) — indirect
    if re.match(r'\(.+\)$', op):
        if mnemonic in ('jmp', 'jml'):
            return 'ind'
        if mnemonic == 'pei':
            return 'dpi'
        return 'dpi'

    # value,x — indexed by X
    if re.match(r'.+,x$', op):
        if size_hint == 'l':
            return 'alx'
        if size_hint == 'b':
            return 'dpx'
        return 'abx'

    # value,y — indexed by Y
    if re.match(r'.+,y$', op):
        if size_hint == 'b':
            return 'dpy'
        return 'aby'

    # Branches always use relative addressing
    if mnemonic in ('bcc', 'bcs', 'beq', 'bne', 'bpl', 'bmi',
                     'bvc', 'bvs', 'bra', 'blt', 'bge'):
        return 'rel'
    if mnemonic == 'brl':
        return 'rll'

    # JSL always long
    if mnemonic == 'jsl':
        return 'abl'

    # JML — determine from size hint
    if mnemonic == 'jml':
        if op.startswith('['):
            return 'ail'
        return 'abl'

    # Plain value — determine from size hint or value
    if size_hint == 'l':
        return 'abl'
    if size_hint == 'b':
        return 'dp'
    if size_hint == 'w':
        return 'abs'

    # Guess from literal hex value
    if op.startswith('$'):
        hex_digits = op[1:].split(',')[0].split('+')[0].split('-')[0]
        if len(hex_digits) <= 2:
            return 'dp'
        if len(hex_digits) <= 4:
            return 'abs'
        return 'abl'

    # PEA is always absolute
    if mnemonic == 'pea':
        return 'abs'
    # PER is always relative long
    if mnemonic == 'per':
        return 'rll'

    # Default: absolute (most symbols in compiler output)
    return 'abs'


# ---------------------------------------------------------------------------
# Instruction parser
# ---------------------------------------------------------------------------

def parse_line(line):
    """Parse a single assembly line.

    Returns:
        dict with keys: 'type' ('instruction', 'label', 'directive', 'empty'),
        and for instructions: 'mnemonic', 'addr_mode', 'operand', 'raw'
    """
    # Strip trailing comment
    stripped = line.split(';')[0]
    # Also strip C-style comments
    stripped = re.sub(r'/\*.*?\*/', '', stripped)
    stripped = stripped.rstrip()

    if not stripped:
        return {'type': 'empty'}

    # Global label at column 0 (letters, digits, underscore, colon)
    if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*:', stripped):
        name = stripped.split(':')[0]
        return {'type': 'label', 'name': name, 'global': True}

    # Local label (@ prefix, or +/- labels)
    if re.match(r'^[@+\-]', stripped.lstrip()):
        return {'type': 'label', 'name': stripped.strip().rstrip(':'), 'global': False}

    # WLA-DX directive
    if stripped.lstrip().startswith('.'):
        return {'type': 'directive', 'raw': stripped.strip()}

    # Instruction (tab or space indented)
    text = stripped.strip()
    if not text:
        return {'type': 'empty'}

    # Split mnemonic and operand
    parts = text.split(None, 1)
    mnemonic_full = parts[0].lower()
    operand = parts[1].strip() if len(parts) > 1 else ''

    # Extract size hint from suffix (.b, .w, .l)
    size_hint = None
    mnemonic = mnemonic_full
    if '.' in mnemonic_full:
        base, suffix = mnemonic_full.rsplit('.', 1)
        if suffix in ('b', 'w', 'l') and base in CYCLES:
            mnemonic = base
            size_hint = suffix

    # Skip unknown mnemonics (data directives like .db, .dw, etc.)
    if mnemonic not in CYCLES:
        return {'type': 'unknown', 'raw': text}

    addr_mode = parse_addressing_mode(mnemonic, operand, size_hint)

    return {
        'type': 'instruction',
        'mnemonic': mnemonic,
        'addr_mode': addr_mode,
        'operand': operand,
        'raw': text,
    }


def get_cycles(mnemonic, addr_mode, m_flag, x_flag, branches_taken=False):
    """Calculate cycle cost for an instruction.

    Args:
        mnemonic: instruction mnemonic (lowercase)
        addr_mode: addressing mode string
        m_flag: 0 = 16-bit A, 1 = 8-bit A
        x_flag: 0 = 16-bit X/Y, 1 = 8-bit X/Y
        branches_taken: if True, add +1 for conditional branches

    Returns:
        Cycle count (int), or 0 if unknown
    """
    modes = CYCLES.get(mnemonic)
    if not modes:
        return 0

    base = modes.get(addr_mode, 0)
    if base == 0:
        # Fallback: try 'imp' for implied instructions
        base = modes.get('imp', 0)

    cycles = base

    # m-flag adjustments (16-bit accumulator)
    if m_flag == 0:
        if mnemonic in M_PLUS1:
            cycles += 1
        elif mnemonic in M_PLUS2 and addr_mode != 'acc':
            cycles += 2

    # x-flag adjustments (16-bit index)
    if x_flag == 0:
        if mnemonic in X_PLUS1:
            cycles += 1

    # Branch taken penalty
    if branches_taken and addr_mode == 'rel' and mnemonic != 'bra':
        cycles += 1

    return cycles


def update_flags(mnemonic, operand, m_flag, x_flag):
    """Track m/x flag state through SEP/REP instructions.

    Returns: (new_m_flag, new_x_flag)
    """
    if mnemonic not in ('sep', 'rep'):
        return m_flag, x_flag

    # Parse the immediate value
    val_match = re.search(r'#\$([0-9a-fA-F]+)', operand)
    if not val_match:
        val_match = re.search(r'#(\d+)', operand)
        if not val_match:
            return m_flag, x_flag
        val = int(val_match.group(1))
    else:
        val = int(val_match.group(1), 16)

    if mnemonic == 'sep':
        # SEP sets bits (8-bit mode)
        if val & 0x20:
            m_flag = 1
        if val & 0x10:
            x_flag = 1
    elif mnemonic == 'rep':
        # REP clears bits (16-bit mode)
        if val & 0x20:
            m_flag = 0
        if val & 0x10:
            x_flag = 0

    return m_flag, x_flag


# ---------------------------------------------------------------------------
# File analyzer
# ---------------------------------------------------------------------------

def analyze_file(filename, branches_taken=False, verbose=False):
    """Analyze an assembly file and return per-function cycle counts.

    Returns:
        OrderedDict of {func_name: {'instructions': int, 'cycles': int,
                                     'details': [(line, mnemonic, mode, cycles)]}}
    """
    functions = OrderedDict()
    current_func = None
    m_flag = 0  # 16-bit A (compiler default)
    x_flag = 0  # 16-bit X/Y (compiler default)

    with open(filename, 'r') as f:
        lines = f.readlines()

    for line in lines:
        parsed = parse_line(line)

        if parsed['type'] == 'label' and parsed['global']:
            name = parsed['name']
            # Skip data labels (variables in RAMSECTION etc.)
            # Heuristic: if next non-empty line is rtl or an instruction, it's a function
            current_func = name
            if name not in functions:
                functions[name] = {
                    'instructions': 0,
                    'cycles': 0,
                    'details': [],
                }
            # Reset flags at function entry (compiler default: 16-bit mode)
            m_flag = 0
            x_flag = 0
            continue

        if parsed['type'] == 'directive':
            raw = parsed['raw']
            # .ENDS marks section end
            if raw.upper().startswith('.ENDS'):
                current_func = None
            continue

        if parsed['type'] != 'instruction':
            continue

        if current_func is None:
            continue

        mnemonic = parsed['mnemonic']
        addr_mode = parsed['addr_mode']
        operand = parsed['operand']

        # Track flag state
        m_flag, x_flag = update_flags(mnemonic, operand, m_flag, x_flag)

        cycles = get_cycles(mnemonic, addr_mode, m_flag, x_flag, branches_taken)

        func = functions[current_func]
        func['instructions'] += 1
        func['cycles'] += cycles
        if verbose:
            func['details'].append((parsed['raw'], mnemonic, addr_mode, cycles))

    # Remove "functions" that have 0 instructions (data labels)
    functions = OrderedDict(
        (k, v) for k, v in functions.items() if v['instructions'] > 0
    )

    return functions


# ---------------------------------------------------------------------------
# Output formatters
# ---------------------------------------------------------------------------

def print_report(functions, filename, verbose=False):
    """Print analysis report to stdout."""
    total_inst = 0
    total_cycles = 0

    print(f"=== Cycle Analysis: {filename} ===")
    print()

    # Column widths
    max_name = max((len(n) for n in functions), default=10)
    max_name = max(max_name, 8)

    print(f"  {'FUNCTION':<{max_name}}  {'INSTR':>6}  {'CYCLES':>7}")
    print(f"  {'-' * max_name}  {'------':>6}  {'-------':>7}")

    for name, data in functions.items():
        inst = data['instructions']
        cyc = data['cycles']
        total_inst += inst
        total_cycles += cyc
        print(f"  {name:<{max_name}}  {inst:>6}  {cyc:>7}")

        if verbose and data['details']:
            for raw, mnem, mode, c in data['details']:
                print(f"    {c:>3}  {raw}")
            print()

    print(f"  {'-' * max_name}  {'------':>6}  {'-------':>7}")
    print(f"  {'TOTAL':<{max_name}}  {total_inst:>6}  {total_cycles:>7}")
    print()


def print_comparison(funcs_before, funcs_after, file_before, file_after):
    """Print comparison between two analyses."""
    all_names = list(dict.fromkeys(
        list(funcs_before.keys()) + list(funcs_after.keys())
    ))

    max_name = max((len(n) for n in all_names), default=10)
    max_name = max(max_name, 8)

    print(f"=== Comparison: {file_before} -> {file_after} ===")
    print()
    print(f"  {'FUNCTION':<{max_name}}  {'BEFORE':>7}  {'AFTER':>7}  {'DELTA':>7}  {'%':>7}")
    print(f"  {'-' * max_name}  {'-------':>7}  {'-------':>7}  {'-------':>7}  {'-------':>7}")

    total_before = 0
    total_after = 0

    for name in all_names:
        cyc_b = funcs_before.get(name, {}).get('cycles', 0)
        cyc_a = funcs_after.get(name, {}).get('cycles', 0)
        delta = cyc_a - cyc_b
        total_before += cyc_b
        total_after += cyc_a

        if cyc_b > 0:
            pct = f"{delta / cyc_b * 100:+.1f}%"
        elif cyc_a > 0:
            pct = "NEW"
        else:
            pct = ""

        delta_str = f"{delta:+d}" if delta != 0 else "0"

        # Highlight improvements in the delta
        print(f"  {name:<{max_name}}  {cyc_b:>7}  {cyc_a:>7}  {delta_str:>7}  {pct:>7}")

    total_delta = total_after - total_before
    if total_before > 0:
        total_pct = f"{total_delta / total_before * 100:+.1f}%"
    else:
        total_pct = ""
    total_delta_str = f"{total_delta:+d}" if total_delta != 0 else "0"

    print(f"  {'-' * max_name}  {'-------':>7}  {'-------':>7}  {'-------':>7}  {'-------':>7}")
    print(f"  {'TOTAL':<{max_name}}  {total_before:>7}  {total_after:>7}  {total_delta_str:>7}  {total_pct:>7}")
    print()


def output_json(functions, filename):
    """Output analysis as JSON."""
    result = {
        'file': filename,
        'functions': {},
        'total_instructions': 0,
        'total_cycles': 0,
    }
    for name, data in functions.items():
        result['functions'][name] = {
            'instructions': data['instructions'],
            'cycles': data['cycles'],
        }
        result['total_instructions'] += data['instructions']
        result['total_cycles'] += data['cycles']
    print(json.dumps(result, indent=2))


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(
        description='65816 assembly cycle counter for OpenSNES compiler output',
        epilog='Reference: https://wiki.superfamicom.org/65816-reference',
    )
    parser.add_argument('files', nargs='+', metavar='FILE',
                        help='.asm file(s) to analyze')
    parser.add_argument('--compare', action='store_true',
                        help='compare two .asm files (requires exactly 2 files)')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='show per-instruction cycle breakdown')
    parser.add_argument('--json', action='store_true',
                        help='output as JSON')
    parser.add_argument('--branches-taken', action='store_true',
                        help='count conditional branches as taken (+1 cycle)')
    parser.add_argument('--function', '-f', metavar='NAME',
                        help='analyze only this function')

    args = parser.parse_args()

    if args.compare:
        if len(args.files) != 2:
            parser.error('--compare requires exactly 2 files')
        funcs_a = analyze_file(args.files[0], args.branches_taken)
        funcs_b = analyze_file(args.files[1], args.branches_taken)
        if args.function:
            funcs_a = OrderedDict((k, v) for k, v in funcs_a.items()
                                  if k == args.function)
            funcs_b = OrderedDict((k, v) for k, v in funcs_b.items()
                                  if k == args.function)
        print_comparison(funcs_a, funcs_b, args.files[0], args.files[1])
    else:
        for filename in args.files:
            functions = analyze_file(filename, args.branches_taken, args.verbose)
            if args.function:
                functions = OrderedDict(
                    (k, v) for k, v in functions.items() if k == args.function
                )
            if args.json:
                output_json(functions, filename)
            else:
                print_report(functions, filename, args.verbose)


if __name__ == '__main__':
    main()
