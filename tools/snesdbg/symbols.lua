--[[
  symbols.lua - WLA-DX Symbol Table Parser for OpenSNES

  Parses .sym files generated by wla-dx and provides symbol lookup.

  WLA-DX .sym format:
    [labels]
    BB:AAAA symbol_name

  Where BB = bank (hex), AAAA = address (hex)
  Example: 00:81b9 EmptyHandler

  Usage:
    local symbols = require("symbols")
    local symtab = symbols.load("game.sym")
    local addr = symtab:resolve("monster_x")
    local name = symtab:lookup(0x7E0022)
]]

local M = {}

-- Symbol entry structure
-- {name = string, bank = number, addr = number, fullAddr = number}

local SymbolTable = {}
SymbolTable.__index = SymbolTable

--- Create a new SymbolTable
function M.new()
    local self = setmetatable({}, SymbolTable)
    self.byName = {}      -- name -> entry
    self.byAddr = {}      -- fullAddr -> entry
    self.byBank = {}      -- bank -> {entry, ...}
    self.entries = {}     -- all entries in order
    return self
end

--- Parse a WLA-DX .sym file
-- @param path Path to the .sym file
-- @return SymbolTable
function M.load(path)
    local self = M.new()

    local file = io.open(path, "r")
    if not file then
        error("Cannot open symbol file: " .. path)
    end

    local inLabels = false

    for line in file:lines() do
        -- Check for [labels] section
        if line:match("^%[labels%]") then
            inLabels = true
        elseif line:match("^%[") then
            inLabels = false
        elseif inLabels then
            -- Parse: BB:AAAA symbol_name (with colon separator)
            local bankStr, addrStr, name = line:match("^(%x%x):(%x%x%x%x)%s+(.+)$")
            if bankStr and addrStr and name then
                local bank = tonumber(bankStr, 16)
                local addr = tonumber(addrStr, 16)

                local entry = {
                    name = name,
                    bank = bank,
                    addr = addr,
                    fullAddr = (bank * 0x10000) + addr
                }

                self.byName[name] = entry
                self.byAddr[entry.fullAddr] = entry

                if not self.byBank[bank] then
                    self.byBank[bank] = {}
                end
                table.insert(self.byBank[bank], entry)
                table.insert(self.entries, entry)
            end
        end
    end

    file:close()
    return self
end

--- Resolve a symbol name to its full 24-bit address
-- @param name Symbol name
-- @return full address (24-bit), bank, local address, or nil if not found
function SymbolTable:resolve(name)
    local entry = self.byName[name]
    if entry then
        return entry.fullAddr, entry.bank, entry.addr
    end
    return nil
end

--- Lookup a symbol by address
-- @param addr Full 24-bit address or local address
-- @param bank Optional bank (if addr is 16-bit)
-- @return symbol name, or nil if not found
function SymbolTable:lookup(addr, bank)
    local fullAddr
    if bank then
        fullAddr = (bank * 0x10000) + addr
    else
        fullAddr = addr
    end

    local entry = self.byAddr[fullAddr]
    if entry then
        return entry.name
    end
    return nil
end

--- Find nearest symbol to an address (for disassembly annotation)
-- @param addr Full 24-bit address
-- @return symbol name, offset from symbol, or nil
function SymbolTable:findNearest(addr)
    local bank = math.floor(addr / 0x10000)
    local localAddr = addr % 0x10000

    local bankEntries = self.byBank[bank]
    if not bankEntries then
        return nil
    end

    local nearest = nil
    local nearestOffset = 0x10000

    for _, entry in ipairs(bankEntries) do
        if entry.addr <= localAddr then
            local offset = localAddr - entry.addr
            if offset < nearestOffset then
                nearest = entry
                nearestOffset = offset
            end
        end
    end

    if nearest and nearestOffset < 0x100 then -- Only show if within 256 bytes
        return nearest.name, nearestOffset
    end
    return nil
end

--- Get all symbols in a bank
-- @param bank Bank number
-- @return array of entries
function SymbolTable:getBank(bank)
    return self.byBank[bank] or {}
end

--- Get all symbols (iterator)
function SymbolTable:all()
    return ipairs(self.entries)
end

--- Check if a symbol exists
function SymbolTable:exists(name)
    return self.byName[name] ~= nil
end

--- Get bank for a symbol (for DMA bank configuration)
-- @param name Symbol name
-- @return bank number or nil
function SymbolTable:getBank(name)
    local entry = self.byName[name]
    if entry then
        return entry.bank
    end
    return nil
end

--- Get count of symbols
function SymbolTable:count()
    return #self.entries
end

--- Get WRAM symbols (Bank $7E and $7F, plus Bank $00 low range)
function SymbolTable:getWRAMSymbols()
    local result = {}

    -- Bank $7E and $7F (full WRAM)
    for _, entry in ipairs(self.byBank[0x7E] or {}) do
        table.insert(result, entry)
    end
    for _, entry in ipairs(self.byBank[0x7F] or {}) do
        table.insert(result, entry)
    end

    -- Bank $00 low range (mirrors $7E:0000-$1FFF)
    for _, entry in ipairs(self.byBank[0x00] or {}) do
        if entry.addr < 0x2000 then
            table.insert(result, entry)
        end
    end

    return result
end

--- Check for WRAM mirror overlaps (the critical bug detector)
-- @return array of overlap descriptions, empty if no overlaps
function SymbolTable:checkWRAMOverlap()
    local overlaps = {}

    -- Get Bank $00 symbols in $0000-$1FFF range
    local bank00 = {}
    for _, entry in ipairs(self.byBank[0x00] or {}) do
        if entry.addr < 0x2000 then
            table.insert(bank00, entry)
        end
    end

    -- Get Bank $7E symbols in $0000-$1FFF range
    local bank7E = {}
    for _, entry in ipairs(self.byBank[0x7E] or {}) do
        if entry.addr < 0x2000 then
            table.insert(bank7E, entry)
        end
    end

    -- Check for overlaps
    for _, e00 in ipairs(bank00) do
        for _, e7E in ipairs(bank7E) do
            -- Check if ranges overlap
            -- Assume 1 byte symbols for now (would need size info for better check)
            if e00.addr == e7E.addr then
                table.insert(overlaps, {
                    bank00 = e00,
                    bank7E = e7E,
                    addr = e00.addr,
                    msg = string.format("OVERLAP at $%04X: '%s' (Bank $00) and '%s' (Bank $7E)",
                        e00.addr, e00.name, e7E.name)
                })
            end
        end
    end

    return overlaps
end

--- Format an address with symbol annotation
-- @param addr Full 24-bit address
-- @return formatted string like "$008100 [update_monster+$0F]"
function SymbolTable:formatAddr(addr)
    local name, offset = self:findNearest(addr)
    if name then
        if offset == 0 then
            return string.format("$%06X [%s]", addr, name)
        else
            return string.format("$%06X [%s+$%02X]", addr, name, offset)
        end
    else
        return string.format("$%06X", addr)
    end
end

return M
